(function (Drupal, drupalSettings) {
  Drupal.behaviors.cookieBannerAdminUi = {
    attach: function attach() {

      // Configuration and state used in the script
      const config = {
        textarea: document.getElementById('edit-site-settings'),
        bannerElement: document.getElementById('editor_holder'),
        errorHolderElement: document.getElementById('error_holder'),
        errorHolderElement2: document.getElementById('error_holder2'),
        editorOptions: {
          theme: 'bootstrap3',
          iconlib: 'bootstrap',
          show_opt_in: true,
          disable_edit_json: true,
          disable_properties: true,
          disable_array_delete_all_rows: true,
          disable_array_delete_last_row: true,
          keep_oneof_values: false,
          prompt_before_delete: true,
        },
        defaultLanguages: [
          { "code": "fi", "name": "Finnish", "direction": "ltr" },
          { "code": "sv", "name": "Swedish", "direction": "ltr" },
          { "code": "en", "name": "English", "direction": "ltr" }
        ],
      };

      // state used in the script
      const state = {
        jsonValue: {},
        languages: [],
        schema: {},
        bannerEditor: null,
        textareaErrors: [],
        editorErrors: [],
      };

      /**
       * Utility to debounce a function
       * @param {function} func Function to be debounced
       * @param {number} delay Delay in ms for the debounce
       * @returns {function} The debounced function
       */
      function debounce(func, delay) {
        let timeoutId;
        return (...args) => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => func(...args), delay);
        };
      }

      /**
       * Updates the error messages and classes
       * @returns {void}
       */
      function updateErrors() {
        const errors = [...state.textareaErrors, ...state.editorErrors];
        if (errors.length === 0) {
          config.errorHolderElement.innerHTML = '';
          config.errorHolderElement2.innerHTML = '';
          config.textarea.classList.remove('error');
          return;
        }
        const errorSummary = `
        <div class="alert alert-danger" role="alert">
          <h2 class="alert-heading">Errors found</h2>
          <ul>
            ${ errors.map((error, index) => `<li>Error ${index + 1}: ${
              (error.message) ?
                `<a href="#editor_holder" onclick="window.scrollIntoError(event, '${error.path}', true);">${error.message}</a>` :
                `<a href="#editor_holder" onclick="window.scrollIntoError(event, '#edit-site-settings', false);">${error}</a>`
              }</li>`).join('') }
          </ul>
        </div>`;

        config.errorHolderElement.innerHTML = errorSummary;
        config.errorHolderElement2.innerHTML = errorSummary;
        if (state.textareaErrors.length > 0) {
          config.textarea.classList.add('error');
        } else {
          config.textarea.classList.remove('error');
        }
      }

      /**
       * Parses and returns the textarea value as JSON
       * @returns {object} The parsed object or an empty object if parsing fails
       */
      function getStartValue() {
        let startValue = {};
        try {
          startValue = JSON.parse(config.textarea.value);
          state.textareaErrors = [];

        } catch (error) {
          state.textareaErrors = [`Error parsing the textarea value: ${error}`];
          console.error('Error parsing the textarea value:', error);
        }
        updateErrors();
        return startValue;
      }

      /**
       * Parses the schema from drupalSettings
       * @returns {object} The parsed schema or an empty object if parsing fails
       */
      function getSchema() {
        let schema = {};
        try {
          schema = JSON.parse(drupalSettings.cookieBannerAdminUi.siteSettingsSchema);
        } catch (error) {
          console.error('Error fetching the schema:', error);
        }
        return schema;
      }

      /**
       * Updates the schema with the new languages
       * @param {object} languages JSON generated by the language editor
       * @param {object} schema JSON schema of siteSettings.json
       * @returns {object} updated schema with the new languages
       */
      function updateSchema(languages, schema) {

        // Update the fallback language enum and titles
        const fallbackLanguageEnum = languages.map(lang => lang.code);
        const fallbackLanguageEnumTitles = languages.map(lang => `${lang.code} (${lang.name})`);

        // Get the LocalisedText, reset and update it with the new languages
        const localisedText = schema["$defs"].LocalisedText;
        localisedText.properties = {};
        localisedText.required = [];
        languages.forEach(lang => {
          localisedText.properties[lang.code] = {
            "type": "string",
            "title": `${lang.code} (${lang.name})`,
            "minLength": 1
          };
          localisedText.required.push(lang.code);
        });

        const newSchema = schema;
        newSchema["$defs"].LocalisedText = localisedText;
        newSchema.properties.fallbackLanguage.enum = fallbackLanguageEnum;
        newSchema.properties.fallbackLanguage.options.enum_titles = fallbackLanguageEnumTitles;

        return newSchema;
      }

      /**
       * Initializes the banner editor
       * @param {object} startval The startval for the editor
       */
      function initializeBannerEditor(startval) {

        // Remove event listener and destroy the old editor if it exists on subsequent initializations
        if (state.bannerEditor) {
          state.bannerEditor.off('change', bannerChangeHandler);  // Remove the old listener
          state.bannerEditor.destroy();
        }

        state.bannerEditor = new JSONEditor(config.bannerElement, {
          ...config.editorOptions,
          schema: state.schema,
          startval,
        });
        state.bannerEditor.on('change', debounce(bannerChangeHandler, 100));
      }

      /**
       * Handles changes in the banner editor
       */
      function bannerChangeHandler() {
        const errors = state.bannerEditor.validate();
        state.editorErrors = errors;
        updateErrors();
        if (errors.length) {
          console.error('Not updating textarea due to invalid configuration');
          return;
        }

        const updatedVal = state.bannerEditor.getValue();

        if (JSON.stringify(state.languages) !== JSON.stringify(updatedVal.languages)) {
          state.languages = updatedVal.languages;
          state.schema = updateSchema(state.languages, state.schema);

          initializeBannerEditor(updatedVal);
        } else {
          config.textarea.value = JSON.stringify(updatedVal, null, 2);
        }
      }

      /**
       * Handles input changes in the textarea
       */
      function textareaChangeHandler() {
        try {
          const updatedVal = JSON.parse(config.textarea.value);
          state.textareaErrors = [];

          if (JSON.stringify(state.languages) !== JSON.stringify(updatedVal.languages)) {
            state.languages = updatedVal.languages;
            state.schema = updateSchema(state.languages, state.schema);

            initializeBannerEditor(updatedVal);
          } else {
            if (JSON.stringify(state.jsonValue) != JSON.stringify(updatedVal)) {
              state.bannerEditor.setValue(updatedVal);
              state.jsonValue = updatedVal;
            }
          }
        } catch (error) {
          state.textareaErrors = [`Invalid JSON in textarea: ${error}`];
          console.error('Invalid JSON in textarea:', error);
        }
        updateErrors();
      }

      /**
       * Initializes the editor on page load
       */
      function initialize() {
        window.scrollIntoError = (event, path, isSchemapath) => {
          event.preventDefault();
          let target;
          let focusTarget;
          if(isSchemapath) {
            target = document.getElementById('editor_holder')?.querySelector(`[data-schemapath="${path.replace(/\.oneOf\[\d+\]/, '')}"]`);
            focusTarget = target?.querySelector('input, select, textarea');
          } else {
            target = document.querySelector(path);
          }
          target?.scrollIntoView({ behavior: 'smooth', block: 'center' });
          focusTarget?.focus();
        }

        state.schema = getSchema();
        state.jsonValue = getStartValue();

        state.languages = state.jsonValue.languages || config.defaultLanguages;
        state.jsonValue.languages = state.languages;

        initializeBannerEditor(state.jsonValue);

        config.textarea.addEventListener('input', debounce(textareaChangeHandler, 100));
      }

      // Initialize the editor once the page has loaded
      window.onload = initialize;
    }
  };
})(Drupal, drupalSettings);
